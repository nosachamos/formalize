{"code":"import { useCallback, useEffect, useRef, useState } from 'react';\r\nimport validator from 'validator';\r\nexport const GLOBAL_VALIDATOR_SETTINGS = {\r\n    invalidAttr: { error: true },\r\n    invalidHelperTextAttr: undefined\r\n};\r\nexport const ValidatorDefaults = {};\r\nconst DEFAULT_ERROR_MESSAGE = 'This field is not valid.';\r\nexport const useFormInput = ({ name, formHandler, validation = {}, updateError, invalidAttr = {}, helperTextAttr }) => {\r\n    const [formData, setFormData] = formHandler;\r\n    const formValue = formData[name] || '';\r\n    const [value, setValue] = useState(formValue);\r\n    const [isValid, setIsValid] = useState(true);\r\n    const [isTouched, setIsTouched] = useState(false);\r\n    const [helperText, setHelperText] = useState(void 0);\r\n    const handleValidation = useCallback((value) => {\r\n        const result = validate(value, validation);\r\n        setIsValid(!result);\r\n        if (result) {\r\n            const [unmetRuleKey, errorMessage] = result;\r\n            setHelperText(errorMessage);\r\n            updateError(name, unmetRuleKey, errorMessage);\r\n        }\r\n        else {\r\n            updateError(name);\r\n        }\r\n    }, [name, validation, updateError]);\r\n    // watch for external parent data changes in self\r\n    useEffect(() => {\r\n        if (value !== formValue) {\r\n            setValue(formValue);\r\n            setIsTouched(false);\r\n        }\r\n    }, [formValue, value]);\r\n    // validate on value change\r\n    useEffect(() => {\r\n        if (isTouched) {\r\n            handleValidation(value);\r\n        }\r\n    }, [value, isTouched, handleValidation]);\r\n    // rewrite self and parent's value\r\n    const handleChange = (e) => {\r\n        const { value, type, checked } = e.currentTarget;\r\n        const newValue = type === 'checkbox' ? checked : value;\r\n        setValue(value);\r\n        setFormData(Object.assign({}, formData, { [name]: newValue }));\r\n    };\r\n    const handleBlur = () => {\r\n        if (!isTouched) {\r\n            setIsTouched(true);\r\n        }\r\n        handleValidation(value);\r\n    };\r\n    const showError = !isValid && isTouched;\r\n    let helperTextObj = void 0;\r\n    if (helperTextAttr && helperText !== undefined) {\r\n        helperTextObj = {};\r\n        helperTextObj[helperTextAttr] = helperText;\r\n    }\r\n    const inputAttr = Object.assign({ value,\r\n        name, onChange: handleChange, onBlur: handleBlur }, (showError && helperTextObj), (showError && invalidAttr));\r\n    return inputAttr;\r\n};\r\nexport const useForm = (formRef, defaultValues, handleSubmit, invalidAttr = GLOBAL_VALIDATOR_SETTINGS.invalidAttr, helperTextAttr = GLOBAL_VALIDATOR_SETTINGS.invalidHelperTextAttr) => {\r\n    const formHandler = useState(defaultValues);\r\n    const errorHandler = useState({});\r\n    const [mounted, setMounted] = useState(false);\r\n    const [values, setValues] = formHandler;\r\n    const [errors, setErrors] = errorHandler;\r\n    // initial mounted flag\r\n    useEffect(() => setMounted(true), []);\r\n    const updateError = (name, unmetRule, errorMessage) => {\r\n        if (!unmetRule) {\r\n            delete errors[name];\r\n        }\r\n        else {\r\n            if (errorMessage !== undefined) {\r\n                errors[name] = errorMessage;\r\n            }\r\n        }\r\n        setErrors(errors);\r\n    };\r\n    if (formRef.current) {\r\n        if (!formRef.current.formValidationIdAttr) {\r\n            formRef.current.formValidationIdAttr = Math.random()\r\n                .toString(36)\r\n                .substr(2, 9);\r\n        }\r\n    }\r\n    const formInputsAttrs = useRef({});\r\n    const useInput = (name, validationConfigs) => {\r\n        const inputAttr = useFormInput({\r\n            name,\r\n            validation: validationConfigs,\r\n            formHandler,\r\n            updateError,\r\n            invalidAttr,\r\n            helperTextAttr\r\n        });\r\n        if (formRef.current) {\r\n            if (!formInputsAttrs.current[formRef.current.formValidationIdAttr]) {\r\n                formInputsAttrs.current[formRef.current.formValidationIdAttr] = {};\r\n            }\r\n            formInputsAttrs.current[formRef.current.formValidationIdAttr][inputAttr.name] = inputAttr;\r\n        }\r\n        return inputAttr;\r\n    };\r\n    const validateForm = () => {\r\n        if (formRef.current) {\r\n            const formInputsByName = formInputsAttrs.current[formRef.current.formValidationIdAttr];\r\n            // go through all inputs and trigger validation\r\n            console.log('validate all: ' + Object.keys(formInputsByName).length);\r\n            // trigger validation on each of the form's inputs\r\n            Object.keys(formInputsByName).forEach(inputName => formInputsByName[inputName].onBlur());\r\n        }\r\n        return mounted && !Object.values(errors).length; // no errors found\r\n    };\r\n    const formSubmitHandler = (e) => {\r\n        // first validate the form\r\n        if (validateForm()) {\r\n            try {\r\n                // since the form is valid, delegate to the user-provided submit handler, if one was given to us\r\n                if (handleSubmit) {\r\n                    handleSubmit(e, values);\r\n                }\r\n                else {\r\n                    // by default, we don't submit the form. If the user wants the native submission behavior, they must\r\n                    // provide a submit handler.\r\n                    e.preventDefault();\r\n                    return false;\r\n                }\r\n            }\r\n            catch (e) {\r\n                console.error('An error has happened executing the user-provided form submit handler.');\r\n                console.dir(e);\r\n            }\r\n        }\r\n        else {\r\n            // there were errors, so prevent form submission in all cases\r\n            e.preventDefault();\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    // now find the form with the given ref, and attach our own onSubmit handler which will trigger the entire\r\n    // form validation. If the entire form is found to be valid, it will also trigger the user-provided submit handler.\r\n    if (formRef.current) {\r\n        // we replace the handler so that the new function created during this render, which includes the updated form\r\n        // values available to it through closure, can then be used if the user submits the form.\r\n        if (formRef.current.currentSubmitHandler) {\r\n            formRef.current.removeEventListener('submit', formRef.current.currentSubmitHandler);\r\n        }\r\n        formRef.current.addEventListener('submit', formSubmitHandler);\r\n        formRef.current.currentSubmitHandler = formSubmitHandler;\r\n    }\r\n    return {\r\n        formValues: values,\r\n        setValues,\r\n        useInput,\r\n        validateForm,\r\n        errors,\r\n        isValid: mounted && !Object.values(errors).length\r\n    };\r\n};\r\n/**\r\n * Returns either unmet rule, or null\r\n * @param value\r\n * @param validation\r\n * @returns {*}\r\n */\r\nexport const validate = (value, validation) => {\r\n    const fieldsToValidate = {};\r\n    Object.keys(validation).forEach(property => {\r\n        let options = {}, errorMessage = void 0, negate = void 0, validatorFunction = void 0;\r\n        if (ValidatorDefaults[property]) {\r\n            if (typeof ValidatorDefaults[property] === 'string') {\r\n                // @ts-ignore\r\n                validatorFunction = validator[ValidatorDefaults[property]];\r\n                errorMessage = ValidatorDefaults[property];\r\n                negate = false;\r\n            }\r\n            else {\r\n                const propValidator = ValidatorDefaults[property];\r\n                if (typeof propValidator.validator === 'string') {\r\n                    validatorFunction = validator[propValidator.validator];\r\n                }\r\n                else if (typeof propValidator.validator === 'function') {\r\n                    validatorFunction = propValidator.validator;\r\n                }\r\n                else {\r\n                    throw new Error('The given validator must be either a string or a function.');\r\n                }\r\n                errorMessage = propValidator.errorMessage\r\n                    ? propValidator.errorMessage\r\n                    : DEFAULT_ERROR_MESSAGE;\r\n                negate = propValidator.negate === void 0 ? false : propValidator.negate;\r\n                options = propValidator.options === void 0 ? {} : propValidator.options;\r\n            }\r\n        }\r\n        else {\r\n            // @ts-ignore\r\n            validatorFunction = validator[property];\r\n        }\r\n        fieldsToValidate[property] = {\r\n            errorMessage,\r\n            negate,\r\n            options,\r\n            validator: validatorFunction\r\n        };\r\n        if (typeof validation[property] === 'string') {\r\n            fieldsToValidate[property].errorMessage = validation[property];\r\n        }\r\n        else if (typeof validation[property] === 'boolean') {\r\n            fieldsToValidate[property].negate = validation[property];\r\n        }\r\n        else if (typeof validation[property] === 'function') {\r\n            fieldsToValidate[property].validator = validation[property];\r\n        }\r\n        else if (typeof validation[property] === 'object') {\r\n            fieldsToValidate[property] = Object.assign({}, fieldsToValidate[property], validation[property]);\r\n        }\r\n    });\r\n    // check whether we do need to validate at all - no validation rules, no validation needed\r\n    if (fieldsToValidate.isEmpty) {\r\n        return null;\r\n    }\r\n    let unmetValidationKey = void 0;\r\n    let isValid = true;\r\n    Object.keys(fieldsToValidate).forEach(property => {\r\n        if (unmetValidationKey) {\r\n            return;\r\n        }\r\n        const configs = fieldsToValidate[property];\r\n        switch (property) {\r\n            case 'isRequired':\r\n                if (!value) {\r\n                    unmetValidationKey = property;\r\n                }\r\n                break;\r\n            default:\r\n                if (configs.validator !== undefined) {\r\n                    isValid = configs.validator(value, configs.options);\r\n                }\r\n        }\r\n        if (configs.negate) {\r\n            isValid = !isValid;\r\n        }\r\n        if (!isValid) {\r\n            unmetValidationKey = property;\r\n            return;\r\n        }\r\n    });\r\n    return unmetValidationKey\r\n        ? [unmetValidationKey, fieldsToValidate[unmetValidationKey].errorMessage]\r\n        : null;\r\n};\r\n","dts":{"name":"C:/Work/formalizer/.rpt2_cache/placeholder/formalizer.d.ts","writeByteOrderMark":false,"text":"import { Dispatch, FormEvent, SetStateAction, RefObject } from 'react';\r\ninterface ValidatorSettings {\r\n    invalidAttr?: {\r\n        error: boolean;\r\n    };\r\n    invalidHelperTextAttr?: string;\r\n}\r\nexport declare const GLOBAL_VALIDATOR_SETTINGS: ValidatorSettings;\r\nexport declare const ValidatorDefaults: {\r\n    [key: string]: Formalizer | string;\r\n};\r\ndeclare type ValidatorFunction = (value: any, options: object | undefined) => boolean;\r\ninterface Formalizer {\r\n    errorMessage?: string;\r\n    negate?: boolean;\r\n    options?: object;\r\n    validator?: ValidatorFunction;\r\n}\r\ninterface FormData {\r\n    [key: string]: any;\r\n}\r\ndeclare type FormSubmitHandler = (e: Event, formValues: {\r\n    [ley: string]: any;\r\n}) => boolean;\r\ninterface ValidationConfigs {\r\n    [key: string]: Formalizer;\r\n}\r\ndeclare type ValidationErrorUpdater = (name: string, unmetRuleKey?: string, errorMessage?: string) => void;\r\ninterface FormInputParams {\r\n    name: string;\r\n    formHandler: [FormData, Dispatch<SetStateAction<FormData>>];\r\n    updateError: ValidationErrorUpdater;\r\n    invalidAttr?: object;\r\n    validation: ValidationConfigs;\r\n    helperTextAttr?: string;\r\n}\r\ninterface InputAttributes {\r\n    value: any;\r\n    name: string;\r\n    onChange: (e: FormEvent<HTMLInputElement>) => any;\r\n    onBlur: () => any;\r\n    helperTextObj?: {\r\n        [key: string]: string;\r\n    };\r\n    invalidAttr?: object;\r\n}\r\nexport declare const useFormInput: ({ name, formHandler, validation, updateError, invalidAttr, helperTextAttr }: FormInputParams) => InputAttributes;\r\nexport declare const useForm: (formRef: RefObject<HTMLFormElement>, defaultValues: FormData, handleSubmit: FormSubmitHandler, invalidAttr?: {\r\n    error: boolean;\r\n} | undefined, helperTextAttr?: string | undefined) => {\r\n    formValues: FormData;\r\n    setValues: Dispatch<SetStateAction<FormData>>;\r\n    useInput: (name: string, validationConfigs: ValidationConfigs) => InputAttributes;\r\n    validateForm: () => boolean;\r\n    errors: {\r\n        [key: string]: string;\r\n    };\r\n    isValid: boolean;\r\n};\r\n/**\r\n * Returns either unmet rule, or null\r\n * @param value\r\n * @param validation\r\n * @returns {*}\r\n */\r\nexport declare const validate: (value: any, validation: {\r\n    [key: string]: string | Formalizer;\r\n}) => (string | undefined)[] | null;\r\nexport {};\r\n"}}
